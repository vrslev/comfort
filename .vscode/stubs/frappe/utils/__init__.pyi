"""
This type stub file was generated by pyright.
"""

from __future__ import print_function, unicode_literals

from email.header import decode_header, make_header
from email.utils import formataddr, parseaddr
import functools
from gzip import GzipFile
import hashlib
import io
import json
import os
import re
import sys
import traceback
import typing
from typing import Generator, Iterable
from urllib.parse import quote, urlparse

from werkzeug.test import Client

import frappe
from frappe.utils.data import *
from frappe.utils.html_utils import sanitize_html

default_fields = ...

def get_fullname(user=...):  # -> None:
    """get the full name (first name + last name) of the user from User"""
    ...

def get_email_address(user=...):
    """get the email address of the user from User"""
    ...

def get_formatted_email(user, mail=...):  # -> Literal['']:
    """get Email Address of user formatted as: `John Doe <johndoe@example.com>`"""
    ...

def extract_email_id(email):  # -> Any | str:
    """fetch only the email part of the Email Address"""
    ...

def validate_phone_number(phone_number, throw=...):  # -> bool:
    """Returns True if valid phone number"""
    ...

def validate_name(name, throw=...):  # -> bool:
    """Returns True if the name is valid
    valid names may have unicode and ascii characters, dash, quotes, numbers
    anything else is considered invalid
    """
    ...

def validate_email_address(email_str, throw=...):  # -> str:
    """Validates the email string"""
    ...

def split_emails(txt): ...
def validate_url(txt, throw=..., valid_schemes=...):  # -> bool:
    """
    Checks whether `txt` has a valid URL string

    Parameters:
            throw (`bool`): throws a validationError if URL is not valid
            valid_schemes (`str` or `list`): if provided checks the given URL's scheme against this

    Returns:
            bool: if `txt` represents a valid URL
    """
    ...

def random_string(length):  # -> str:
    """generate a random string"""
    ...

def has_gravatar(email):  # -> str:
    """Returns gravatar url if user has set an avatar at gravatar.com"""
    ...

def get_gravatar_url(email): ...
def get_gravatar(email): ...
def get_traceback() -> str:
    """
    Returns the traceback of the Exception
    """
    ...

def log(event, details): ...
def dict_to_str(args, sep=...):
    """
    Converts a dictionary to URL
    """
    ...

def list_to_str(seq, sep=...):
    """Convert a sequence into a string using seperator.

    Same as str.join, but does type conversion and strip extra spaces.
    """
    ...

def get_defaults(key=...):
    """
    Get dictionary of default values from the defaults, or a value if key is passed
    """
    ...

def set_default(key, val):
    """
    Set / add a default value to defaults`
    """
    ...

def remove_blanks(d):
    """
    Returns d with empty ('' or None) values stripped
    """
    ...

def strip_html_tags(text):  # -> str:
    """Remove html tags from text"""
    ...

def get_file_timestamp(fn):  # -> str | None:
    """
    Returns timestamp of the given file
    """
    ...

def make_esc(esc_chars):  # -> (s: Unknown) -> str:
    """
    Function generator for Escaping special characters
    """
    ...

def esc(s, esc_chars):  # -> Literal['']:
    """
    Escape special characters
    """
    ...

def unesc(s, esc_chars):
    """
    UnEscape special characters
    """
    ...

def execute_in_shell(cmd, verbose=..., low_priority=...): ...
def get_path(*path, **kwargs): ...
def get_site_base_path(sites_dir=..., hostname=...): ...
def get_site_path(*path): ...
def get_files_path(*path, **kwargs): ...
def get_bench_path(): ...
def get_backups_path(): ...
def get_request_site_address(full_address=...): ...
def get_site_url(site): ...
def encode_dict(d, encoding=...): ...
def decode_dict(d, encoding=...): ...
@functools.lru_cache()
def get_site_name(hostname): ...
def get_disk_usage():  # -> int:
    """get disk usage of files folder"""
    ...

def touch_file(path): ...
def get_test_client(): ...
def get_hook_method(hook_name, fallback=...): ...
def call_hook_method(hook, *args, **kwargs): ...
def is_cli() -> bool:
    """Returns True if current instance is being run via a terminal"""
    ...

def update_progress_bar(txt, i, l): ...
def get_html_format(print_path): ...
def is_markdown(text): ...
def get_sites(sites_path=...): ...
def get_request_session(max_retries=...): ...
def watch(path, handler=..., debug=...):  # -> None:
    class Handler(FileSystemEventHandler): ...

def markdown(text, sanitize=..., linkify=...): ...
def sanitize_email(emails): ...
def parse_addr(
    email_string,
):  # -> tuple[str, str] | tuple[Any | str, Any] | tuple[None, str]:
    """
    Return email_id and user_name based on email string
    Raise error if email string is not valid
    """
    ...

def check_format(email_id):  # -> Literal[False]:
    """
    Check if email_id is valid. valid email:text@example.com
    String check ensures that email_id contains both '.' and
    '@' and index of '@' is less than '.'
    """
    ...

def get_name_from_email_string(email_string, email_id, name): ...
def get_installed_apps_info(): ...
def get_site_info(): ...
def parse_json(val):  # -> Any:
    """
    Parses json if string else return
    """
    ...

def get_db_count(*args):  # -> Any:
    """
    Pass a doctype or a series of doctypes to get the count of docs in them
    Parameters:
            *args: Variable length argument list of doctype names whose doc count you need

    Returns:
            dict: A dict with the count values.

    Example:
            via terminal:
                    bench --site erpnext.local execute frappe.utils.get_db_count --args "['DocType', 'Communication']"
    """
    ...

def call(fn, *args, **kwargs):  # -> Any:
    """
    Pass a doctype or a series of doctypes to get the count of docs in them
    Parameters:
            fn: frappe function to be called

    Returns:
            based on the function you call: output of the function you call

    Example:
            via terminal:
                    bench --site erpnext.local execute frappe.utils.call --args '''["frappe.get_all", "Activity Log"]''' --kwargs '''{"fields": ["user", "creation", "full_name"], "filters":{"Operation": "Login", "Status": "Success"}, "limit": "10"}'''
    """
    ...

def gzip_compress(data, compresslevel=...):  # -> bytes:
    """Compress data in one shot and return the compressed string.
    Optional argument is the compression level, in range of 0-9.
    """
    ...

def gzip_decompress(data):  # -> bytes:
    """Decompress a gzip compressed string in one shot.
    Return the decompressed string.
    """
    ...

def get_safe_filters(filters): ...
def create_batch(iterable: Iterable, size: int) -> Generator[Iterable, None, None]:
    """Convert an iterable to multiple batches of constant size of batch_size

    Args:
            iterable (Iterable): Iterable object which is subscriptable
            size (int): Maximum size of batches to be generated

    Yields:
            Generator[List]: Batched iterable of maximum length `size`
    """
    ...

def set_request(**kwargs): ...
def get_html_for_route(route): ...
def get_file_size(path, format=...): ...
def get_build_version(): ...
def get_bench_relative_path(file_path):  # -> str:
    """Fixes paths relative to the bench root directory if exists and returns the absolute path

    Args:
            file_path (str, Path): Path of a file that exists on the file system

    Returns:
            str: Absolute path of the file_path
    """
    ...

def groupby_metric(
    iterable: typing.Dict[str, list], key: str
):  # -> dict[Unknown, Unknown]:
    """Group records by a metric.

    Usecase: Lets assume we got country wise players list with the ranking given for each player(multiple players in a country can have same ranking aswell).
    We can group the players by ranking(can be any other metric) using this function.

    >>> d = {
            'india': [{'id':1, 'name': 'iplayer-1', 'ranking': 1}, {'id': 2, 'ranking': 1, 'name': 'iplayer-2'}, {'id': 2, 'ranking': 2, 'name': 'iplayer-3'}],
            'Aus': [{'id':1, 'name': 'aplayer-1', 'ranking': 1}, {'id': 2, 'ranking': 1, 'name': 'aplayer-2'}, {'id': 2, 'ranking': 2, 'name': 'aplayer-3'}]
    }
    >>> groupby(d, key='ranking')
    {1: {'Aus': [{'id': 1, 'name': 'aplayer-1', 'ranking': 1},
                            {'id': 2, 'name': 'aplayer-2', 'ranking': 1}],
            'india': [{'id': 1, 'name': 'iplayer-1', 'ranking': 1},
                            {'id': 2, 'name': 'iplayer-2', 'ranking': 1}]},
    2: {'Aus': [{'id': 2, 'name': 'aplayer-3', 'ranking': 2}],
            'india': [{'id': 2, 'name': 'iplayer-3', 'ranking': 2}]}}
    """
    ...
