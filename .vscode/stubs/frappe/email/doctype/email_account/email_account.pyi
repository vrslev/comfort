"""
This type stub file was generated by pyright.
"""

import frappe
from frappe.model.document import Document

class SentEmailInInbox(Exception): ...
class InvalidEmailCredentials(frappe.ValidationError): ...

class EmailAccount(Document):
    def autoname(self):  # -> None:
        """Set name as `email_account_name` or make title from Email Address."""
        ...
    def validate(self):  # -> None:
        """Validate Email Address and check POP3/IMAP and SMTP connections is enabled."""
        ...
    def before_save(self): ...
    def on_update(self):  # -> None:
        """Check there is only one default of each type."""
        ...
    def there_must_be_only_one_default(self):  # -> None:
        """If current Email Account is default, un-default all other accounts."""
        ...
    @frappe.whitelist()
    def get_domain(self, email_id):  # -> None:
        """look-up the domain and then full"""
        ...
    def check_smtp(self):  # -> None:
        """Checks SMTP settings."""
        ...
    def get_incoming_server(
        self, in_receive=..., email_sync_rule=...
    ):  # -> EmailServer | None:
        """Returns logged in POP3/IMAP connection object."""
        ...
    def check_email_server_connection(self, email_server, in_receive): ...
    @classmethod
    def throw_invalid_credentials_exception(cls): ...
    def handle_incoming_connect_error(self, description): ...
    def set_failed_attempts_count(self, value): ...
    def get_failed_attempts_count(self): ...
    def receive(self, test_mails=...):  # -> None:
        """Called by scheduler to receive emails from this EMail account using POP3/IMAP."""
        ...
    def handle_bad_emails(self, email_server, uid, raw, reason): ...
    def insert_communication(self, msg, args=...): ...
    def set_thread(self, communication, email):  # -> None:
        """Appends communication to parent based on thread ID. Will extract
        parent communication and will link the communication to the reference of that
        communication. Also set the status of parent transaction to Open or Replied.

        If no thread id is found and `append_to` is set for the email account,
        it will create a new parent transaction (e.g. Issue)"""
        ...
    def set_sender_field_and_subject_field(self):  # -> None:
        """Identify the sender and subject fields from the `append_to` DocType"""
        ...
    def find_parent_based_on_subject_and_sender(self, communication, email):  # -> None:
        """Find parent document based on subject and sender match"""
        ...
    def create_new_parent(self, communication, email):  # -> None:
        """If no parent found, create a new reference document"""
        ...
    def find_parent_from_in_reply_to(self, communication, email):  # -> None:
        """Returns parent reference if embedded in In-Reply-To header

        Message-ID is formatted as `{message_id}@{site}`"""
        ...
    def send_auto_reply(self, communication, email):  # -> None:
        """Send auto reply if set."""
        ...
    def get_unreplied_notification_emails(self):  # -> list[Unknown]:
        """Return list of emails listed"""
        ...
    def on_trash(self):  # -> None:
        """Clear communications where email account is linked"""
        ...
    def after_rename(self, old, new, merge=...): ...
    def build_email_sync_rule(self): ...
    def mark_emails_as_read_unread(self):  # -> None:
        """mark Email Flag Queue of self.email_account mails as read"""
        ...
    def set_communication_seen_status(self, docnames, seen=...):  # -> None:
        """mark Email Flag Queue of self.email_account mails as read"""
        ...
    def check_automatic_linking_email_account(self): ...
    def append_email_to_sent_folder(self, message): ...

@frappe.whitelist()
def get_append_to(
    doctype=..., txt=..., searchfield=..., start=..., page_len=..., filters=...
): ...
def test_internet(host=..., port=..., timeout=...):  # -> bool:
    """Returns True if internet is connected

    Host: 8.8.8.8 (google-public-dns-a.google.com)
    OpenPort: 53/tcp
    Service: domain (DNS/TCP)
    """
    ...

def notify_unreplied():  # -> None:
    """Sends email notifications if there are unreplied Communications
    and `notify_if_unreplied` is set as true."""
    ...

def pull(now=...):  # -> None:
    """Will be called via scheduler, pull emails from all enabled Email accounts."""
    ...

def pull_from_email_account(email_account):  # -> None:
    """Runs within a worker process"""
    ...

def get_max_email_uid(email_account): ...
